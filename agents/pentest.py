"""
deepagents_hitl_runner.py

Example runner that creates a DeepAgent with nmap/sqlmap tools and forces
Human-In-The-Loop approval for any tool calls.

Requirements:
  pip install deepagents langgraph
  (and your nmap/sqlmap tools files should be importable)
"""

from deepagents import create_deep_agent
from langgraph.checkpoint.memory import InMemorySaver
from langgraph.types import Command
import json
import uuid
from langchain.chat_models import init_chat_model

# Replace these imports with the actual module paths where you saved the tools.
# Example: from tools.nmap_tool_langchain import nmap_tool
#          from tools.sqlmap_tool_deepagents import sqlmap_tool
# from nmap_tool_langchain import nmap_tool
# from sqlmap_tool_deepagents import sqlmap_tool
from tools import nmap_tool, sqlmap_tool, mssql, authenticate


def build_agent(model="gemini-2.0-flash", provider="google_genai"):
    """
    Create the deep agent with HITL enforcement for sensitive tools.
    tool_configs maps tool-name -> HumanInTheLoopConfig (True == full allow).
    """
    security_instructions = """You are an expert security testing assistant. Your job is to design safe, minimal-impact security tests, get operator approval, run approved tests, and produce clear findings and remediation steps.

You have access to the following tools:

## `nmap_tool`
Use this tool for network/service discovery and vulnerability detection via Nmap. Typical uses:
 - Discovery of live hosts and open ports (start with a light scan).
 - Service/version detection and vulnerability script checks.
Important notes:
 - This environment forces XML output by default (the tool returns `xml` in the response).
 - Example call (must use these exact parameter names):
   nmap_tool(target="192.168.1.100", arguments="-sV --script vuln", ports="1-65535", force_xml=True)
 - Prefer small, targeted scans first (specific ports or limited ranges). Do NOT run broad aggressive scans without explicit justification.

## `sqlmap_tool`
Use this tool only to verify SQL injection *after* a potential injection point is identified (e.g., from app params or vulnerable web forms).
 - Default behavior includes `--batch` so it runs non-interactively.
 - Example call:
   sqlmap_tool(url="http://example/item?id=1", arguments="-p id --risk=2 --level=2", timeout=600)
 - Do not use sqlmap for large-scale crawling or brute-forcing credentials. Require explicit operator consent for any intrusive option (e.g., `--threads`, `--os-shell`, `--dbs`).

## Human-in-the-loop policy (MANDATORY)
1. **Plan first**: Before calling any tool, produce a short plan describing:
   - Which tool you propose to call,
   - The exact function call you will execute (show function name and all argument values),
   - Why the scan is needed and its expected impact (duration, network load, possible service disruption).
2. **Wait for operator approval**: After presenting the plan, **do not call the tool** until the operator either:
   - `accept`s (explicit approval), or
   - `edit`s the proposed call (you must then show the edited call and wait for approval), or
   - `respond`s with textual instructions (do not execute the tool).
3. **When operator `accept`s**, immediately execute the previously approved function call exactly as shown. Do not alter parameters after approval unless the operator explicitly edits and re-approves.
4. **After execution**, parse results (for nmap, parse the XML; for sqlmap, capture stdout) and present:
   - concise summary of findings,
   - raw output attached (or the XML/text) for operator inspection,
   - recommended next steps and risk assessment.
5. **Always** ask the operator before escalating to more intrusive actions (OS shell, password extraction, destructive tests).

## Safety & authorization
- Only scan hosts you are explicitly authorized to test. At the start of the session ask the operator to confirm authorization (yes/no) and include that confirmation in the session metadata.
- Prefer non-intrusive defaults: light discovery, limited ports, and `--batch` for sqlmap.
- If uncertain, ask the operator for clarification rather than guessing.

## Examples of correct dialog flow (agent behavior)
1. Produce plan:
   - \"Plan: run nmap tool to detect open ports on 192.168.1.100. Proposed call:
      nmap_tool(target='192.168.1.100', arguments='-sS -sV --script vuln', ports='1-1024', force_xml=True).
      Expected duration: ~2 minutes; impact: low.\"
2. Wait for operator approval.
3. On `accept` resume: run the exact `nmap_tool(...)` call, capture XML, parse summary, present results.
4. On `edit` receive new call JSON from operator, validate it, then run after approval.
5. On `respond` append operator message to conversation and do not run the tool.

Follow these instructions strictly. The operator controls all executions."""

    # Init the chat model
    llm = init_chat_model(model=model, model_provider=provider)

    nmap = nmap_tool.make_langchain_tool()
    sqlmap = sqlmap_tool.make_langchain_tool()
    mssql_auth = authenticate.make_langchain_tool()

    # We name the tools by their function name: nmap_tool, sqlmap_tool
    tools = [nmap, sqlmap, mssql_auth]

    # Require human approval/edit/respond for both tools.
    # Setting True is a shortcut that allows accept/edit/respond.
    tool_configs = {
        "nmap_tool": True,
        "sqlmap_tool": True,
        "mssql_check_credentials": True,
    }

    agent = create_deep_agent(
        tools=tools,
        instructions=security_instructions,
        interrupt_config=tool_configs,
        model=llm,
    )

    # Attach an in-memory checkpointer so Human-in-the-Loop works locally.
    checkpointer = InMemorySaver()
    agent.checkpointer = checkpointer

    return agent


def prompt_human_for_resume():
    """
    Ask operator what to do when agent pauses for approval.
    Returns a `resume` list as expected by Command(resume=[...])
    """
    print("\n=== HUMAN-IN-THE-LOOP PROMPT ===")
    print("Options:")
    print("  1) accept         -> allow the tool to run as-is")
    print("  2) edit           -> edit which tool/args to run")
    print(
        "  3) respond        -> do NOT run tool, instead append a textual response to the agent"
    )
    print("  4) abort          -> stop the agent entirely\n")

    choice = input("Choose [1/2/3/4]: ").strip()
    if choice == "1":
        return [{"type": "accept"}]
    elif choice == "2":
        # For edit, operator provides JSON like: {"action": "nmap_tool", "args": {"target":"1.2.3.4","arguments":"-sV -p80"}}
        print("\nEnter edited tool call as JSON.")
        print(
            'Example: {"action":"nmap_tool","args":{"target":"192.168.1.100","arguments":"-sV -p22,80"}}'
        )
        raw = input("Edited call JSON: ").strip()
        try:
            payload = json.loads(raw)
            # Basic validation
            if "action" not in payload or "args" not in payload:
                raise ValueError("must include 'action' and 'args' keys")
            return [{"type": "edit", "args": payload}]
        except Exception as e:
            print("Invalid JSON / format:", e)
            print("Falling back to respond with a message instead.")
            return [
                {
                    "type": "response",
                    "args": "Operator provided invalid edit; aborting tool call.",
                }
            ]
    elif choice == "3":
        text = input(
            "Enter textual response to append (this will NOT run the tool): "
        ).strip()
        return [{"type": "response", "args": text}]
    else:
        # abort / anything else -> send a response indicating abort
        return [{"type": "response", "args": "Operator aborted the test."}]


def run_interactive_scan(agent, user_prompt: str):
    """
    Run the agent on `user_prompt`. This demo runs until the agent reaches a HITL interrupt,
    then prompts the user and resumes with the chosen Command.
    """
    thread_id = str(uuid.uuid4())
    config = {"configurable": {"thread_id": thread_id}}

    print("Starting agent (will pause when a tool requiring approval is proposed)...\n")
    # First pass: agent.stream will go until it hits an interrupt and then return control
    for chunk in agent.stream(
        {"messages": [{"role": "user", "content": user_prompt}]}, config=config
    ):
        # In a real UI you would render chunk contents progressively. Here we print.
        print("STREAM CHUNK:", chunk)

    # When the agent paused for human approval, we now ask the operator what to do
    resume_payload = prompt_human_for_resume()

    print("\nResuming agent with operator decision...\n")
    # Resume by sending the Command with resume payload.
    for chunk in agent.stream(Command(resume=resume_payload), config=config):
        print("STREAM CHUNK:", chunk)

    print("\nAgent run complete.")


if __name__ == "__main__":
    print("=== DeepAgents HITL demo runner ===")
    agent = build_agent()

    # Operator must explicitly confirm they have permission to test the target.
    ok = (
        input(
            "Do you confirm you have authorization to test systems you will specify? [yes/no]: "
        )
        .strip()
        .lower()
    )
    if ok not in ("y", "yes"):
        print("Authorization not confirmed. Exiting.")
        exit(1)

    # Example prompt (modify as desired)
    prompt = input(
        "Enter the security testing instruction for the agent (e.g. 'Scan 192.168.1.100 for open ports and vulnerabilities'):\n"
    )

    run_interactive_scan(agent, prompt)
